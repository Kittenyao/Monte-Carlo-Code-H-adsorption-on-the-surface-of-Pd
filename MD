1.	#Python: Monte Carlo Simulation by Z. Yao  
2.	import numpy as nm  
3.	import matplotlib.pyplot as plt  
4.	#    Function_1: Energy Calculation  
5.	def Energy(M,V1,V2,u):  
6.	    M_Left       =  nm.roll(M      ,-1,axis=1)        #Periodic boundary condition  
7.	    M_Right      =  nm.roll(M      , 1,axis=1)  
8.	    M_Up         =  nm.roll(M      ,-1,axis=0)  
9.	    M_Down       =  nm.roll(M      , 1,axis=0)  
10.	    M_Left_Up    =  nm.roll(M_Left ,-1,axis=0)  
11.	    M_Left_Down  =  nm.roll(M_Left , 1,axis=0)  
12.	    M_Right_Up   =  nm.roll(M_Right,-1,axis=0)  
13.	    M_Right_Down =  nm.roll(M_Right, 1,axis=0)        #Applying ising model to calculate energy  
14.	    iEnergy      =  0.5*V1*(M*M_Left+M*M_Right+M*M_Up+M*M_Down)+0.5*V2*(M*M_Left_Up+M*M_Right_Up+M*M_Left_Down+M*M_Right_Down)-u*(M)  
15.	    return nm.sum(iEnergy)  
16.	#    Function_2: Heat Capacity Calculation  
17.	def Cv(M,V1,V2,u,T):  
18.	    N            =  nm.size(M)  
19.	    M_Left       =  nm.roll(M      ,-1,axis=1)        #Periodic boundary condition  
20.	    M_Right      =  nm.roll(M      , 1,axis=1)  
21.	    M_Up         =  nm.roll(M      ,-1,axis=0)  
22.	    M_Down       =  nm.roll(M      , 1,axis=0)  
23.	    M_Left_Up    =  nm.roll(M_Left ,-1,axis=0)  
24.	    M_Left_Down  =  nm.roll(M_Left , 1,axis=0)  
25.	    M_Right_Up   =  nm.roll(M_Right,-1,axis=0)  
26.	    M_Right_Down =  nm.roll(M_Right, 1,axis=0)        #Applying ising model to calculate energy  
27.	    iEnergy      =  0.5*V1*(M*M_Left+M*M_Right+M*M_Up+M*M_Down)+0.5*V2*(M*M_Left_Up+M*M_Right_Up+M*M_Left_Down+M*M_Right_Down)-u*(M)  
28.	    C            =  (nm.sum(iEnergy**2)/N-(nm.sum(iEnergy)/N)**2)/T**2        #Calculate heat capacity  
29.	    return C  
30.	#    Function_3: Monte Carlo Step  
31.	def MCStep(M,V1,V2,u,T):  
32.	    for N_sites in range(0,nm.size(M)):  
33.	        RND      =  nm.random.rand()                                 #Random number x in (0,1)  
34.	        i        =  nm.random.choice(range(0,nm.shape(M)[1]))        #Randomly select one spin to flip  
35.	        j        =  nm.random.choice(range(0,nm.shape(M)[1]))  
36.	        M_i      =  nm.copy(M)  
37.	        M_f      =  nm.copy(M)  
38.	        M_f[i,j] =  (-1)*M_i[i,j]  
39.	        E_i      =  Energy(M_i,V1,V2,u)                              #Metropolis algorithm  
40.	        E_f      =  Energy(M_f,V1,V2,u)  
41.	        Diff_E   =  E_f-E_i  
42.	        P        =  nm.exp(-Diff_E/T)  
43.	        if P     >  RND:  
44.	            M    =  nm.copy(M_f)  
45.	        else:  
46.	            M    =  nm.copy(M_i)  
47.	        return M  
48.	  
49.	#    Main Code  
50.	Dim    =    70        #System dimension  
51.	V1     =   1.0        #Reduced units: Chemical potential unit: m/|V1|; Temperature unit: kT/|V1|  
52.	V2     =  -2.0  
53.	N_Equi = 10000        #Step number for equlibrating  
54.	N_Samp = 20000        #Step number for sampling  
55.	u_max  =     8        #Chemical potential range  
56.	u_min  =    -8  
57.	u_step =   0.2  
58.	T_max  =    10        #Temperature range  
59.	T_min  =     0  
60.	T_step =   0.5  
61.	Matrix =  nm.ones([Dim,Dim])        #System initiation: uniform  
62.	for T in nm.arange(T_min,T_max+T_step,T_step):  
63.	    S_Cv_vs_u=open('S_Cv_vs_u for T = %s.csv'%T,'w')  
64.	    U      =    []  
65.	    S      =    []  
66.	    C      =    []  
67.	    for u in nm.arange(u_min,u_max+u_step,u_step):  
68.	        Sigma_eq      =  [nm.sum(Matrix)/nm.size(Matrix)]         
69.	        C_eq          =  [Cv(Matrix,V1,V2,u,T)]  
70.	        for N_steps in range(0,N_Equi):                          #Equilibrating runs  
71.	            Matrix    =  nm.copy(MCStep(Matrix,V1,V2,u,T))  
72.	            Sigma_eq.append(nm.sum(Matrix)/(nm.size(Matrix)))  
73.	            C_eq.append(Cv(Matrix,V1,V2,u,T))  
74.	        Sigma_samp    =  []  
75.	        C_samp        =  []  
76.	        for N_steps in range(0,N_Samp):                          #Sampling runs  
77.	            Matrix    =  nm.copy(MCStep(Matrix,V1,V2,u,T))  
78.	            Sigma_samp.append(nm.sum(Matrix)/(nm.size(Matrix)))  
79.	            C_samp.append(Cv(Matrix,V1,V2,u,T))  
80.	        S_avg         =  nm.sum(Sigma_samp)/len(Sigma_samp)      #Averaging  
81.	        C_avg         =  nm.sum(C_samp)/len(C_samp)  
82.	        S_Cv_vs_u.write("%s,%s,%s,%s\n"%(T,u,S_avg,C_avg))       #Output  
83.	        U.append(u)  
84.	        S.append(S_avg)  
85.	        C.append(C_avg)      
86.	    S_Cv_vs_u.close()  
87.	    fig,ax1 =  plt.subplots()                                    #Plotting  
88.	    ax2     =  ax1.twinx()  
89.	    ax1.plot(U,S,'b-s')  
90.	    ax2.plot(U,C,'r-s')                                          
91.	    ax1.set_xlabel(r'Chemical Potential $\mu$')  
92.	    ax1.set_ylabel(r'Composition <$\sigma$>')  
93.	    ax2.set_ylabel(r'Heat Capacity Cv')  
94.	    plt.title(r'Temperature=%s'%T)  
95.	    plt.savefig('Composition_Cv_u Temperature=%s.png'%T,transparent=True)  
96.	    plt.close()  
97.	#    Code End  
